<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bagh Chal - ‡§¨‡§æ‡§ò ‡§ö‡§æ‡§≤</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --panel-bg: rgba(255,255,255,0.05);
            --panel-border: rgba(255,255,255,0.1);
            --text-primary: #e0e0e0;
            --text-secondary: #a8a8a8;
            --text-muted: #bbb;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --tiger-color: #e94560;
            --tiger-grad-start: #ff8a65;
            --tiger-grad-end: #c0392b;
            --tiger-border: #e74c3c;
            --goat-color: #4CAF50;
            --goat-grad-start: #a5d6a7;
            --goat-grad-end: #2e7d32;
            --goat-border: #4CAF50;
            --board-bg: rgba(30, 30, 50, 0.8);
            --grid-line: rgba(255,255,255,0.15);
            --gold: #ffd700;
        }

        [data-theme="traditional"] {
            --bg-primary: #5D4037;
            --bg-secondary: #6D4C41;
            --bg-tertiary: #795548;
            --panel-bg: rgba(0,0,0,0.2);
            --panel-border: rgba(255,255,255,0.15);
            --accent: #FF8F00;
            --accent-hover: #FFA726;
            --board-bg: rgba(62, 39, 25, 0.9);
            --grid-line: rgba(255,220,180,0.3);
        }

        [data-theme="modern"] {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --bg-tertiary: #21262D;
            --panel-bg: rgba(255,255,255,0.04);
            --panel-border: rgba(255,255,255,0.08);
            --accent: #58A6FF;
            --accent-hover: #79C0FF;
            --tiger-color: #F85149;
            --goat-color: #3FB950;
            --board-bg: rgba(13, 17, 23, 0.9);
            --grid-line: rgba(255,255,255,0.1);
        }

        body {
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--text-primary);
            line-height: 1.5;
        }

        header {
            text-align: center;
            padding: 16px 20px 8px;
        }
        header h1 {
            font-size: 2.2rem;
            color: var(--accent);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        header h2 {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: normal;
            margin-top: 2px;
        }

        /* ===== START MENU ===== */
        .start-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 480px;
            width: 100%;
        }
        .start-menu h3 {
            color: var(--accent);
            font-size: 1.3rem;
            margin-bottom: 20px;
        }
        .mode-cards {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            margin-bottom: 24px;
        }
        .mode-card {
            background: var(--panel-bg);
            border: 2px solid var(--panel-border);
            border-radius: 16px;
            padding: 24px 20px;
            width: 160px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .mode-card:hover {
            border-color: var(--accent);
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        .mode-card .icon { font-size: 2.5rem; margin-bottom: 12px; }
        .mode-card .title { font-weight: bold; font-size: 1.1rem; margin-bottom: 6px; }
        .mode-card .desc { font-size: 0.8rem; color: var(--text-muted); }

        .difficulty-select {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        .difficulty-select.show { display: flex; }
        .difficulty-select h4 {
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        .diff-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .diff-btn {
            padding: 10px 24px;
            border-radius: 10px;
            border: 2px solid var(--panel-border);
            background: var(--panel-bg);
            color: var(--text-primary);
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        .diff-btn:hover {
            border-color: var(--accent);
            background: rgba(233, 69, 96, 0.15);
        }

        .side-select {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 16px;
            width: 100%;
        }
        .side-select.show { display: flex; }
        .side-buttons {
            display: flex;
            gap: 10px;
        }
        .side-btn {
            padding: 12px 28px;
            border-radius: 10px;
            border: 2px solid var(--panel-border);
            background: var(--panel-bg);
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        .side-btn:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        /* ===== GAME AREA ===== */
        .game-container {
            display: none;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 24px;
            padding: 8px 20px 20px;
        }
        .game-container.show { display: flex; }

        .info-panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 20px;
            width: 220px;
            backdrop-filter: blur(10px);
        }
        .info-panel h3 {
            color: var(--accent);
            margin-bottom: 12px;
            font-size: 1rem;
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 8px;
        }
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .stat-label { color: var(--text-secondary); }
        .stat-value { color: #fff; font-weight: bold; }

        .turn-indicator {
            text-align: center;
            padding: 12px;
            margin-bottom: 12px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s;
        }
        .turn-indicator.your-turn {
            animation: turn-pulse 1.5s ease-in-out infinite;
        }
        @keyframes turn-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255,215,0,0); }
            50% { box-shadow: 0 0 12px 4px rgba(255,215,0,0.3); }
        }
        .turn-tiger {
            background: rgba(233, 69, 96, 0.2);
            border: 1px solid var(--tiger-color);
            color: var(--tiger-color);
        }
        .turn-goat {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid var(--goat-color);
            color: var(--goat-color);
        }

        .phase-indicator {
            text-align: center;
            padding: 6px;
            margin-bottom: 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            background: rgba(255,255,255,0.05);
            color: #ccc;
        }

        #board-container {
            position: relative;
            width: 420px;
            height: 420px;
            border-radius: 18px;
            overflow: hidden;
            box-shadow: 0 4px 24px rgba(0,0,0,0.4), inset 0 0 0 2px rgba(255,255,255,0.06);
        }
        #board-canvas {
            position: absolute;
            top: 0; left: 0;
            cursor: pointer;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 220px;
        }

        .rules-panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            font-size: 0.8rem;
            line-height: 1.5;
        }
        .rules-panel h3 {
            color: var(--accent);
            margin-bottom: 10px;
            font-size: 1rem;
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 8px;
        }
        .rules-panel ul {
            padding-left: 16px;
            color: var(--text-muted);
        }
        .rules-panel li { margin-bottom: 6px; }
        .rules-panel .tiger-text { color: var(--tiger-color); font-weight: bold; }
        .rules-panel .goat-text { color: var(--goat-color); font-weight: bold; }

        .move-history-panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        .move-history-panel h3 {
            color: var(--accent);
            margin-bottom: 10px;
            font-size: 1rem;
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 8px;
        }
        #move-list {
            max-height: 120px;
            overflow-y: auto;
            font-size: 0.78rem;
            color: var(--text-muted);
            line-height: 1.6;
        }
        #move-list::-webkit-scrollbar { width: 4px; }
        #move-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        .move-entry { padding: 2px 0; }
        .move-entry .move-num { color: var(--text-secondary); margin-right: 4px; }
        .move-entry .move-tiger { color: var(--tiger-color); }
        .move-entry .move-goat { color: var(--goat-color); }

        .btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border: none;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-restart {
            background: linear-gradient(135deg, var(--accent), var(--tiger-grad-end));
            color: #fff;
        }
        .btn-restart:hover {
            background: linear-gradient(135deg, var(--accent-hover), var(--accent));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(233, 69, 96, 0.4);
        }
        .btn-undo {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
            border: 1px solid var(--panel-border);
        }
        .btn-undo:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }
        .btn-undo:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        .btn-menu {
            background: rgba(255,255,255,0.08);
            color: var(--text-secondary);
            border: 1px solid var(--panel-border);
            font-size: 0.82rem;
        }
        .btn-menu:hover {
            background: rgba(255,255,255,0.12);
        }

        /* ===== TOOLBAR ===== */
        .toolbar {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 4px;
        }
        .toolbar label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        .toolbar select {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--panel-border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.8rem;
            cursor: pointer;
        }
        .sound-toggle {
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid var(--panel-border);
            background: var(--panel-bg);
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sound-toggle:hover { background: rgba(255,255,255,0.1); }

        /* ===== STATS PANEL ===== */
        .stats-bar {
            display: flex;
            gap: 16px;
            justify-content: center;
            padding: 4px;
            font-size: 0.78rem;
            color: var(--text-secondary);
        }
        .stats-bar span { white-space: nowrap; letter-spacing: 0.02em; }
        .stats-bar .val { color: #fff; font-weight: bold; }

        /* ===== WIN OVERLAY ===== */
        .message-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        .message-overlay.show { display: flex; }
        .message-box {
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
            border: 2px solid var(--accent);
            border-radius: 20px;
            padding: 36px;
            text-align: center;
            max-width: 400px;
            animation: scaleIn 0.3s ease;
        }
        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .message-box h2 { font-size: 1.8rem; margin-bottom: 8px; color: var(--gold); }
        .message-box p { font-size: 1rem; color: #ccc; margin-bottom: 20px; }
        .message-box .btn {
            width: auto;
            display: inline-block;
            padding: 10px 28px;
            margin: 0 6px;
        }

        /* ===== AI THINKING INDICATOR ===== */
        .ai-thinking {
            display: none;
            text-align: center;
            padding: 10px;
            margin-bottom: 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            background: rgba(255,165,0,0.15);
            border: 1px solid rgba(255,165,0,0.3);
            color: #ffb347;
        }
        .ai-thinking.show { display: flex; align-items: center; justify-content: center; gap: 6px; }
        .ai-thinking .dot { display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: #ffb347; animation: dot-bounce 1.2s infinite; }
        .ai-thinking .dot:nth-child(2) { animation-delay: 0.2s; }
        .ai-thinking .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes dot-bounce {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-4px); opacity: 1; }
        }

        /* ===== REPLAY CONTROLS ===== */
        .replay-bar {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,165,0,0.1);
            border: 1px solid rgba(255,165,0,0.25);
            border-radius: 10px;
            margin-bottom: 8px;
        }
        .replay-bar.show { display: flex; }
        .replay-bar button {
            padding: 6px 12px;
            border: 1px solid var(--panel-border);
            border-radius: 6px;
            background: var(--panel-bg);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        .replay-bar button:hover { background: rgba(255,255,255,0.12); }
        .replay-bar button:disabled { opacity: 0.4; cursor: not-allowed; }
        .replay-bar .replay-info {
            font-size: 0.8rem;
            color: var(--text-secondary);
            min-width: 80px;
            text-align: center;
        }

        @media (max-width: 940px) {
            .game-container { flex-direction: column; align-items: center; }
            .info-panel, .right-panel { width: 420px; max-width: 95vw; }
            .right-panel { flex-direction: row; flex-wrap: wrap; }
            .rules-panel, .move-history-panel { flex: 1; min-width: 180px; }
        }
        @media (max-width: 600px) {
            .stats-bar { flex-wrap: wrap; gap: 8px 16px; }
            .toolbar { flex-wrap: wrap; justify-content: center; }
            #rules-content { display: none; }
            .mode-card { width: 130px; padding: 18px 14px; }
            .mode-card .icon { font-size: 2rem; }
        }
        @media (max-width: 460px) {
            #board-container { width: 340px; height: 340px; }
            header h1 { font-size: 1.6rem; }
            .info-panel, .right-panel { width: 340px; }
            .btn { min-height: 44px; }
            .diff-btn, .side-btn { min-height: 44px; }
        }
    </style>
</head>
<body>
    <header>
        <h1>‡§¨‡§æ‡§ò ‡§ö‡§æ‡§≤ ‚Äî Bagh Chal</h1>
        <h2>The Tiger Moving Game of Nepal</h2>
    </header>

    <!-- Toolbar -->
    <div class="toolbar" id="toolbar">
        <label>Theme:</label>
        <select id="theme-select" onchange="changeTheme(this.value)">
            <option value="dark">Dark</option>
            <option value="traditional">Traditional</option>
            <option value="modern">Modern</option>
        </select>
        <label>Board:</label>
        <select id="skin-select" onchange="changeSkin(this.value)">
            <option value="classic">Classic</option>
            <option value="wood">Wood</option>
            <option value="marble">Marble</option>
            <option value="neon">Neon</option>
            <option value="nepal">Nepal</option>
        </select>
        <button class="sound-toggle" id="sound-btn" onclick="toggleSound()">Sound: ON</button>
    </div>

    <!-- Session Stats -->
    <div class="stats-bar" id="stats-bar">
        <span>Played: <span class="val" id="stat-played">0</span></span>
        <span>Tiger Wins: <span class="val" id="stat-tiger-wins">0</span></span>
        <span>Goat Wins: <span class="val" id="stat-goat-wins">0</span></span>
        <span>Streak: <span class="val" id="stat-streak">0</span></span>
        <span>ELO: <span class="val" id="stat-elo">1000</span></span>
    </div>

    <!-- Start Menu -->
    <div class="start-menu" id="start-menu">
        <h3>Choose Game Mode</h3>
        <div class="mode-cards">
            <div class="mode-card" onclick="selectMode('human')">
                <div class="icon">üë•</div>
                <div class="title">2 Players</div>
                <div class="desc">Play with a friend on the same device</div>
            </div>
            <div class="mode-card" onclick="selectMode('ai')">
                <div class="icon">ü§ñ</div>
                <div class="title">vs Computer</div>
                <div class="desc">Challenge the AI opponent</div>
            </div>
            <div class="mode-card" onclick="selectMode('online')">
                <div class="icon">üåê</div>
                <div class="title">Online</div>
                <div class="desc">Play with a friend via link</div>
            </div>
        </div>

        <div class="difficulty-select" id="difficulty-select">
            <h4>Select Difficulty</h4>
            <div class="diff-buttons">
                <button class="diff-btn" onclick="selectDifficulty('easy')">Easy</button>
                <button class="diff-btn" onclick="selectDifficulty('medium')">Medium</button>
                <button class="diff-btn" onclick="selectDifficulty('hard')">Hard</button>
            </div>
        </div>

        <div class="side-select" id="side-select">
            <h4>Play as</h4>
            <div class="side-buttons">
                <button class="side-btn" onclick="startAIGame('goat')">üêê Goats</button>
                <button class="side-btn" onclick="startAIGame('tiger')">üêÖ Tigers</button>
            </div>
        </div>

        <div class="online-lobby" id="online-lobby" style="display:none; flex-direction:column; align-items:center; gap:14px; width:100%;">
            <h4 style="color:var(--text-secondary);">Online Multiplayer</h4>
            <div class="diff-buttons">
                <button class="diff-btn" onclick="createOnlineGame()">Create Game</button>
                <button class="diff-btn" onclick="showJoinInput()">Join Game</button>
            </div>
            <div id="online-create-info" style="display:none; text-align:center;">
                <p style="font-size:0.85rem; color:var(--text-muted); margin-bottom:8px;">Share this code with your friend:</p>
                <div style="font-size:1.8rem; font-weight:bold; color:var(--gold); letter-spacing:4px; cursor:pointer;" id="room-code" onclick="copyRoomCode()" title="Click to copy"></div>
                <p style="font-size:0.75rem; color:var(--text-secondary); margin-top:6px;" id="online-status">Waiting for opponent...</p>
            </div>
            <div id="online-join-info" style="display:none; text-align:center;">
                <p style="font-size:0.85rem; color:var(--text-muted); margin-bottom:8px;">Enter the game code:</p>
                <input type="text" id="join-code-input" maxlength="6" style="padding:10px 16px; font-size:1.3rem; text-align:center; letter-spacing:4px; text-transform:uppercase; border-radius:10px; border:2px solid var(--panel-border); background:var(--panel-bg); color:var(--text-primary); width:180px;" placeholder="CODE">
                <br><button class="diff-btn" style="margin-top:10px;" onclick="joinOnlineGame()">Connect</button>
                <p style="font-size:0.75rem; color:var(--text-secondary); margin-top:6px;" id="join-status"></p>
            </div>
        </div>
    </div>

    <!-- Game Area -->
    <div class="game-container" id="game-container">
        <div class="info-panel">
            <div id="turn-indicator" class="turn-indicator turn-goat">Goat's Turn</div>
            <div id="phase-indicator" class="phase-indicator">Phase 1: Place Goats</div>
            <div class="ai-thinking" id="ai-thinking">AI thinking<span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
            <h3>Game Status</h3>
            <div class="stat">
                <span class="stat-label">Goats Placed</span>
                <span class="stat-value" id="goats-placed">0 / 20</span>
            </div>
            <div class="stat">
                <span class="stat-label">Goats Captured</span>
                <span class="stat-value" id="goats-captured">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Tigers Trapped</span>
                <span class="stat-value" id="tigers-trapped">0</span>
            </div>
            <h3 style="margin-top: 16px;">Win Conditions</h3>
            <div style="font-size: 0.8rem; color: var(--text-muted); line-height: 1.5;">
                <p><span style="color: var(--tiger-color); font-weight: bold;">Tigers</span> win by capturing 5 goats</p>
                <p style="margin-top: 4px;"><span style="color: var(--goat-color); font-weight: bold;">Goats</span> win by trapping all 4 tigers</p>
            </div>
            <button class="btn btn-undo" id="undo-btn" onclick="undoMove()" disabled>Undo Move</button>
            <button class="btn btn-restart" onclick="restartGame()">New Game</button>
            <button class="btn btn-menu" onclick="backToMenu()">Main Menu</button>
        </div>

        <div style="display:flex; flex-direction:column; align-items:center;">
            <div class="replay-bar" id="replay-bar">
                <button onclick="replayStep(-1)" id="replay-prev">&#9664; Prev</button>
                <button onclick="replayTogglePlay()" id="replay-play">&#9654; Play</button>
                <button onclick="replayStep(1)" id="replay-next">Next &#9654;</button>
                <span class="replay-info" id="replay-info">0 / 0</span>
                <button onclick="exitReplay()">&#10005; Exit</button>
            </div>
            <div id="board-container">
                <canvas id="board-canvas"></canvas>
            </div>
        </div>

        <div class="right-panel">
            <div class="rules-panel">
                <h3 onclick="toggleRules()" style="cursor:pointer; user-select:none;">How to Play <span id="rules-toggle" style="float:right; font-size:0.8rem; opacity:0.6;">&#9660;</span></h3>
                <ul id="rules-content">
                    <li><span class="tiger-text">4 Tigers</span> start at the corners</li>
                    <li><span class="goat-text">20 Goats</span> are placed one per turn</li>
                    <li>After all goats placed, both sides move</li>
                    <li>Pieces move along lines to adjacent spots</li>
                    <li>Tigers capture goats by jumping over them</li>
                    <li>Goats cannot jump</li>
                </ul>
            </div>
            <div class="move-history-panel">
                <h3>Move History</h3>
                <div id="move-list"></div>
            </div>
        </div>
    </div>

    <!-- Win Overlay -->
    <div class="message-overlay" id="message-overlay">
        <div class="message-box">
            <div id="win-piece-icon" style="font-size:3rem; margin-bottom:8px;"></div>
            <h2 id="message-title">Game Over</h2>
            <p id="message-text">Someone wins!</p>
            <p id="elo-change" style="display:none; font-size:0.9rem; font-weight:bold; margin-bottom:12px;"></p>
            <button class="btn btn-restart" onclick="restartGame()">Play Again</button>
            <button class="btn btn-menu" id="rematch-btn" onclick="requestRematch()" style="display:none; background:rgba(88,166,255,0.2); border-color:rgba(88,166,255,0.4); color:#58a6ff;">Rematch</button>
            <button class="btn btn-menu" onclick="startReplay()" style="background:rgba(255,165,0,0.2); border-color:rgba(255,165,0,0.4); color:#ffb347;">Replay</button>
            <button class="btn btn-menu" onclick="backToMenu()" style="background:rgba(255,255,255,0.1);">Menu</button>
        </div>
    </div>

    <script>
    // ============================================================
    //  BAGH CHAL ‚Äî Full Game Engine with AI, Themes, Stats, Undo
    // ============================================================

    const BOARD_SIZE = 5;
    const TOTAL_GOATS = 20;
    const GOATS_TO_WIN = 5;

    // ===== ADJACENCY =====
    const adjacency = {};
    function posKey(r, c) { return `${r},${c}`; }
    function parseKey(k) { const [r, c] = k.split(',').map(Number); return { r, c }; }

    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++)
            adjacency[posKey(r, c)] = [];

    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (c + 1 < BOARD_SIZE) {
                adjacency[posKey(r, c)].push(posKey(r, c + 1));
                adjacency[posKey(r, c + 1)].push(posKey(r, c));
            }
            if (r + 1 < BOARD_SIZE) {
                adjacency[posKey(r, c)].push(posKey(r + 1, c));
                adjacency[posKey(r + 1, c)].push(posKey(r, c));
            }
        }
    }

    const diagDirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if ((r + c) % 2 === 0) {
                for (const [dr, dc] of diagDirs) {
                    const nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        const a = posKey(r, c), b = posKey(nr, nc);
                        if (!adjacency[a].includes(b)) adjacency[a].push(b);
                        if (!adjacency[b].includes(a)) adjacency[b].push(a);
                    }
                }
            }
        }
    }

    // ===== SOUND ENGINE (Web Audio API) =====
    let soundEnabled = true;
    let audioCtx = null;

    function getAudioCtx() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
    }

    function playTone(freq, duration, type = 'sine', volume = 0.15) {
        if (!soundEnabled) return;
        try {
            const ctx = getAudioCtx();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(volume, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + duration);
        } catch (e) { /* audio not supported */ }
    }

    function soundPlace() { playTone(600, 0.12, 'sine', 0.12); }
    function soundMove() { playTone(440, 0.1, 'triangle', 0.1); }
    function soundCapture() { playTone(220, 0.25, 'sawtooth', 0.1); setTimeout(() => playTone(180, 0.2, 'sawtooth', 0.08), 100); }
    function effectCapture(key) { spawnCaptureParticles(key); triggerShake(); startEffectsLoop(); }
    function effectWin() { spawnConfetti(); startEffectsLoop(); }
    function soundSelect() { playTone(800, 0.06, 'sine', 0.08); }
    function soundWin() { [0, 150, 300, 450].forEach((d, i) => setTimeout(() => playTone(400 + i * 100, 0.3, 'sine', 0.12), d)); }
    function soundUndo() { playTone(300, 0.1, 'triangle', 0.08); }
    function soundYourTurn() {
        playTone(523, 0.15, 'sine', 0.12);
        setTimeout(() => playTone(659, 0.15, 'sine', 0.12), 150);
        setTimeout(() => playTone(784, 0.2, 'sine', 0.12), 300);
    }

    function notifyYourTurn() {
        soundYourTurn();
        // Browser notification for background tab
        if (document.hidden && 'Notification' in window && Notification.permission === 'granted') {
            new Notification('Bagh Chal', { body: "It's your turn!", icon: 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><circle cx="16" cy="16" r="15" fill="%23e94560"/><text x="16" y="22" text-anchor="middle" font-size="20">!</text></svg>') });
        }
        // Flash title when tab is hidden
        if (document.hidden) {
            const origTitle = document.title;
            const flashInterval = setInterval(() => {
                document.title = document.title === origTitle ? "Your Turn!" : origTitle;
            }, 1000);
            const handler = () => { clearInterval(flashInterval); document.title = origTitle; };
            document.addEventListener('visibilitychange', handler, { once: true });
            setTimeout(() => { clearInterval(flashInterval); document.title = origTitle; }, 30000);
        }
    }

    function toggleSound() {
        soundEnabled = !soundEnabled;
        document.getElementById('sound-btn').textContent = `Sound: ${soundEnabled ? 'ON' : 'OFF'}`;
    }

    // ===== THEME & BOARD SKINS =====
    let currentSkin = 'classic';

    const SKIN_CONFIG = {
        classic: {
            boardBg: null,  // use CSS variable
            lineColor: null,
            lineWidth: 1.5,
            dotColor: 'rgba(255,255,255,0.25)',
            pieceStyle: 'gradient' // gradient, flat, or emoji-only
        },
        wood: {
            boardBg: '#8B6914',
            boardBg2: '#6B4E12',
            lineColor: 'rgba(40,25,10,0.6)',
            lineWidth: 2,
            dotColor: 'rgba(40,25,10,0.4)',
            pieceStyle: 'gradient'
        },
        marble: {
            boardBg: '#d0cfc8',
            boardBg2: '#b8b5aa',
            lineColor: 'rgba(80,80,80,0.4)',
            lineWidth: 1.5,
            dotColor: 'rgba(80,80,80,0.35)',
            pieceStyle: 'flat'
        },
        neon: {
            boardBg: '#0a0a1a',
            boardBg2: '#0a0a1a',
            lineColor: 'rgba(0,255,200,0.6)',
            lineWidth: 2,
            dotColor: 'rgba(0,255,200,0.4)',
            pieceStyle: 'gradient'
        },
        nepal: {
            boardBg: '#8B0000',
            boardBg2: '#6B0000',
            lineColor: 'rgba(255,220,150,0.5)',
            lineWidth: 2.5,
            dotColor: 'rgba(255,220,150,0.4)',
            pieceStyle: 'gradient'
        }
    };

    function changeTheme(theme) {
        document.body.removeAttribute('data-theme');
        if (theme !== 'dark') document.body.setAttribute('data-theme', theme);
        drawBoard();
    }

    function changeSkin(skin) {
        currentSkin = skin;
        drawBoard();
    }

    // ===== PIECE SVG IMAGES =====
    // Detailed animal face SVGs rendered as data URI images for cross-platform consistency

    function buildTigerSVG(colors) {
        const c = colors || { body: '#e8922d', bodyDark: '#b56a10', stripe: '#1a0a00', ear: '#d97e1a', earInner: '#ffb366', eye: '#8aff00', eyePupil: '#111', nose: '#2a0a00', whisker: '#ddd', muzzle: '#ffe8c0', white: '#fff4e0', jawLine: '#c06a10' };
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
<defs>
<radialGradient id="tg" cx="50%" cy="38%" r="52%"><stop offset="0%" stop-color="${c.body}"/><stop offset="100%" stop-color="${c.bodyDark}"/></radialGradient>
</defs>
<!-- Wide face shape - tigers have broad, muscular heads -->
<ellipse cx="32" cy="34" rx="29" ry="27" fill="url(#tg)"/>
<!-- Rounded ears - tigers have round ears, not pointed -->
<circle cx="12" cy="12" r="10" fill="${c.ear}"/>
<circle cx="52" cy="12" r="10" fill="${c.ear}"/>
<circle cx="12" cy="12" r="6" fill="${c.earInner}"/>
<circle cx="52" cy="12" r="6" fill="${c.earInner}"/>
<!-- White patches inside ears and around face -->
<ellipse cx="32" cy="42" rx="16" ry="14" fill="${c.muzzle}"/>
<ellipse cx="24" cy="42" rx="8" ry="8" fill="${c.white}" opacity="0.5"/>
<ellipse cx="40" cy="42" rx="8" ry="8" fill="${c.white}" opacity="0.5"/>
<!-- BOLD black stripes - the #1 tiger identifier -->
<path d="M14 16 L18 30" stroke="${c.stripe}" stroke-width="3.5" fill="none" stroke-linecap="round"/>
<path d="M20 12 L22 26" stroke="${c.stripe}" stroke-width="3" fill="none" stroke-linecap="round"/>
<path d="M50 16 L46 30" stroke="${c.stripe}" stroke-width="3.5" fill="none" stroke-linecap="round"/>
<path d="M44 12 L42 26" stroke="${c.stripe}" stroke-width="3" fill="none" stroke-linecap="round"/>
<path d="M26 10 L28 20" stroke="${c.stripe}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
<path d="M38 10 L36 20" stroke="${c.stripe}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
<path d="M8 26 L16 32" stroke="${c.stripe}" stroke-width="3" fill="none" stroke-linecap="round"/>
<path d="M56 26 L48 32" stroke="${c.stripe}" stroke-width="3" fill="none" stroke-linecap="round"/>
<path d="M10 36 L18 38" stroke="${c.stripe}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
<path d="M54 36 L46 38" stroke="${c.stripe}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
<!-- Forehead V-mark -->
<path d="M28 16 L32 22 L36 16" stroke="${c.stripe}" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
<!-- Eyes - fierce, angular -->
<ellipse cx="22" cy="30" rx="6" ry="4.5" fill="white"/>
<ellipse cx="42" cy="30" rx="6" ry="4.5" fill="white"/>
<ellipse cx="23" cy="30" rx="4" ry="3.5" fill="${c.eye}"/>
<ellipse cx="43" cy="30" rx="4" ry="3.5" fill="${c.eye}"/>
<ellipse cx="23.5" cy="30" rx="2" ry="3" fill="${c.eyePupil}"/>
<ellipse cx="43.5" cy="30" rx="2" ry="3" fill="${c.eyePupil}"/>
<circle cx="22" cy="28.5" r="1.5" fill="white" opacity="0.8"/>
<circle cx="42" cy="28.5" r="1.5" fill="white" opacity="0.8"/>
<!-- Big pink/brown nose -->
<path d="M28 38 L32 42 L36 38 Z" fill="${c.nose}"/>
<ellipse cx="32" cy="39" rx="5" ry="3" fill="${c.nose}"/>
<!-- Mouth / jaw line -->
<path d="M32 42 L32 47" stroke="${c.jawLine}" stroke-width="1.5"/>
<path d="M28 47 Q32 50 36 47" stroke="${c.jawLine}" stroke-width="1.2" fill="none"/>
<!-- Whiskers - thick, prominent -->
<line x1="18" y1="38" x2="3" y2="34" stroke="${c.whisker}" stroke-width="1.2" opacity="0.8"/>
<line x1="18" y1="40" x2="3" y2="40" stroke="${c.whisker}" stroke-width="1.2" opacity="0.8"/>
<line x1="18" y1="42" x2="3" y2="46" stroke="${c.whisker}" stroke-width="1.2" opacity="0.8"/>
<line x1="46" y1="38" x2="61" y2="34" stroke="${c.whisker}" stroke-width="1.2" opacity="0.8"/>
<line x1="46" y1="40" x2="61" y2="40" stroke="${c.whisker}" stroke-width="1.2" opacity="0.8"/>
<line x1="46" y1="42" x2="61" y2="46" stroke="${c.whisker}" stroke-width="1.2" opacity="0.8"/>
<!-- White chin -->
<ellipse cx="32" cy="50" rx="10" ry="6" fill="${c.white}" opacity="0.6"/>
</svg>`;
    }

    function buildGoatSVG(colors) {
        const c = colors || { body: '#f0ece4', bodyDark: '#c8c0b0', horn: '#554433', hornDark: '#332211', hornRidge: '#887766', ear: '#e8c8b8', earInner: '#f0a0a0', eye: '#332211', eyeIris: '#ccaa44', nose: '#a07060', beard: '#bba888', white: '#ffffff', snout: '#e8d0c0' };
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
<defs>
<radialGradient id="gg" cx="50%" cy="40%" r="52%"><stop offset="0%" stop-color="${c.body}"/><stop offset="100%" stop-color="${c.bodyDark}"/></radialGradient>
</defs>
<!-- BIG curved horns - THE defining goat feature -->
<path d="M22 22 Q18 8 12 2 Q8 0 6 4 Q8 10 14 18" fill="${c.horn}" stroke="${c.hornDark}" stroke-width="1"/>
<path d="M42 22 Q46 8 52 2 Q56 0 58 4 Q56 10 50 18" fill="${c.horn}" stroke="${c.hornDark}" stroke-width="1"/>
<!-- Horn ridges for texture -->
<path d="M18 14 Q16 12 14 11" stroke="${c.hornRidge}" stroke-width="1.5" fill="none" opacity="0.6"/>
<path d="M20 18 Q17 15 15 14" stroke="${c.hornRidge}" stroke-width="1.5" fill="none" opacity="0.6"/>
<path d="M46 14 Q48 12 50 11" stroke="${c.hornRidge}" stroke-width="1.5" fill="none" opacity="0.6"/>
<path d="M44 18 Q47 15 49 14" stroke="${c.hornRidge}" stroke-width="1.5" fill="none" opacity="0.6"/>
<!-- Elongated face - goats have long, narrow faces unlike round cats -->
<ellipse cx="32" cy="34" rx="22" ry="25" fill="url(#gg)"/>
<!-- Long snout/muzzle area - much more prominent than cat -->
<ellipse cx="32" cy="44" rx="13" ry="12" fill="${c.snout}"/>
<!-- Droopy ears sticking out sideways - very goat-like -->
<ellipse cx="6" cy="26" rx="10" ry="5" fill="${c.ear}" transform="rotate(-25 6 26)"/>
<ellipse cx="58" cy="26" rx="10" ry="5" fill="${c.ear}" transform="rotate(25 58 26)"/>
<ellipse cx="6" cy="26" rx="6" ry="3" fill="${c.earInner}" transform="rotate(-25 6 26)"/>
<ellipse cx="58" cy="26" rx="6" ry="3" fill="${c.earInner}" transform="rotate(25 58 26)"/>
<!-- Eyes - goats have distinctive horizontal rectangular pupils -->
<ellipse cx="23" cy="30" rx="5" ry="4" fill="${c.white}"/>
<ellipse cx="41" cy="30" rx="5" ry="4" fill="${c.white}"/>
<ellipse cx="23" cy="30" rx="3.5" ry="3.5" fill="${c.eyeIris}"/>
<ellipse cx="41" cy="30" rx="3.5" ry="3.5" fill="${c.eyeIris}"/>
<!-- HORIZONTAL rectangular pupils - unique to goats! -->
<rect x="21" y="29" width="5" height="2.5" rx="0.8" fill="${c.eye}"/>
<rect x="39" y="29" width="5" height="2.5" rx="0.8" fill="${c.eye}"/>
<circle cx="22" cy="28.5" r="1" fill="white" opacity="0.7"/>
<circle cx="40" cy="28.5" r="1" fill="white" opacity="0.7"/>
<!-- Nostrils - goats have prominent nostrils on a wide nose -->
<ellipse cx="32" cy="42" rx="6" ry="4" fill="${c.nose}"/>
<ellipse cx="29" cy="42" rx="2" ry="1.5" fill="${c.eye}" opacity="0.5"/>
<ellipse cx="35" cy="42" rx="2" ry="1.5" fill="${c.eye}" opacity="0.5"/>
<!-- Mouth -->
<path d="M32 46 L32 49" stroke="#99776a" stroke-width="1.2"/>
<path d="M28 49 Q32 52 36 49" stroke="#99776a" stroke-width="1" fill="none"/>
<!-- BEARD - another key goat identifier -->
<path d="M28 52 Q26 58 24 62" stroke="${c.beard}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
<path d="M32 53 Q32 59 31 63" stroke="${c.beard}" stroke-width="3" fill="none" stroke-linecap="round"/>
<path d="M36 52 Q38 58 40 62" stroke="${c.beard}" stroke-width="2.5" fill="none" stroke-linecap="round"/>
<!-- Fur tuft between horns -->
<ellipse cx="32" cy="16" rx="8" ry="5" fill="${c.body}"/>
<path d="M28 14 Q30 10 32 14 Q34 10 36 14" fill="${c.bodyDark}" opacity="0.4"/>
</svg>`;
    }

    // Build and cache piece images
    const PIECE_SVGS = {};
    const pieceImages = {};
    let piecesLoaded = false;

    function initPieceSVGs() {
        PIECE_SVGS.classic = {
            tiger: buildTigerSVG(),
            goat: buildGoatSVG()
        };
        PIECE_SVGS.neon = {
            tiger: buildTigerSVG({ body: '#ff4444', bodyDark: '#cc0000', stripe: '#440000', ear: '#ff3333', earInner: '#ff8888', eye: '#00ff66', eyePupil: '#003300', nose: '#880000', whisker: '#ff6666', muzzle: '#ffaaaa', white: '#ffcccc', jawLine: '#cc0000' }),
            goat: buildGoatSVG({ body: '#44ff88', bodyDark: '#00aa44', horn: '#00ff66', hornDark: '#008833', hornRidge: '#88ffaa', ear: '#33dd77', earInner: '#88ffbb', eye: '#003300', eyeIris: '#00ff44', nose: '#008833', beard: '#33cc66', white: '#ccffdd', snout: '#22cc66' })
        };
        PIECE_SVGS.nepal = {
            tiger: buildTigerSVG({ body: '#ff6633', bodyDark: '#cc3300', stripe: '#330000', ear: '#ee5522', earInner: '#ffaa77', eye: '#ffcc00', eyePupil: '#111', nose: '#440000', whisker: '#ffddaa', muzzle: '#ffcc99', white: '#ffe8cc', jawLine: '#cc3300' }),
            goat: buildGoatSVG()
        };
        // wood and marble use classic
        PIECE_SVGS.wood = PIECE_SVGS.classic;
        PIECE_SVGS.marble = PIECE_SVGS.classic;
    }

    function preloadPieceImages() {
        initPieceSVGs();
        let remaining = 0;
        for (const skin of Object.keys(PIECE_SVGS)) {
            if (PIECE_SVGS[skin] === PIECE_SVGS.classic && skin !== 'classic') continue; // skip aliases
            for (const type of ['tiger', 'goat']) {
                remaining++;
                const img = new Image();
                const svgStr = PIECE_SVGS[skin][type];
                img.onload = () => { if (--remaining === 0) piecesLoaded = true; };
                img.onerror = () => { remaining--; };
                img.src = 'data:image/svg+xml,' + encodeURIComponent(svgStr);
                if (!pieceImages[skin]) pieceImages[skin] = {};
                pieceImages[skin][type] = img;
            }
        }
        // Copy aliases
        pieceImages.wood = pieceImages.classic;
        pieceImages.marble = pieceImages.classic;
    }

    function getPieceImage(type) {
        const skinKey = pieceImages[currentSkin] ? currentSkin : 'classic';
        return pieceImages[skinKey]?.[type];
    }

    // ===== STATISTICS (localStorage) =====
    let stats = { played: 0, tigerWins: 0, goatWins: 0, streak: 0, lastWinner: null, elo: 1000 };

    function loadStats() {
        try {
            const s = JSON.parse(localStorage.getItem('baghchal_stats'));
            if (s) stats = s;
        } catch (e) {}
        updateStatsUI();
    }

    function saveStats() {
        try { localStorage.setItem('baghchal_stats', JSON.stringify(stats)); } catch (e) {}
        updateStatsUI();
    }

    function updateStatsUI() {
        document.getElementById('stat-played').textContent = stats.played;
        document.getElementById('stat-tiger-wins').textContent = stats.tigerWins;
        document.getElementById('stat-goat-wins').textContent = stats.goatWins;
        document.getElementById('stat-streak').textContent = stats.streak;
        document.getElementById('stat-elo').textContent = stats.elo || 1000;
    }

    // ELO calculation
    const AI_ELO = { easy: 600, medium: 1100, hard: 1500 };

    function calcEloChange(playerElo, opponentElo, won) {
        const K = stats.played < 10 ? 40 : 20; // higher K for new players
        const expected = 1 / (1 + Math.pow(10, (opponentElo - playerElo) / 400));
        const actual = won ? 1 : 0;
        return Math.round(K * (actual - expected));
    }

    function recordWin(winner) {
        stats.played++;
        if (winner === 'tiger') stats.tigerWins++;
        else stats.goatWins++;
        if (stats.lastWinner === winner) stats.streak++;
        else stats.streak = 1;
        stats.lastWinner = winner;

        // ELO update (only for AI games)
        if (gameMode === 'ai') {
            const playerWon = (winner === playerSide);
            const aiElo = AI_ELO[aiDifficulty] || 1100;
            const change = calcEloChange(stats.elo, aiElo, playerWon);
            stats.elo = Math.max(100, stats.elo + change);
        }

        saveStats();
    }

    // ===== GAME STATE =====
    let board = {};
    let goatsPlaced = 0;
    let goatsCaptured = 0;
    let currentTurn = 'goat';
    let selectedPiece = null;
    let gameOver = false;
    let validMoves = [];
    let moveHistory = [];     // array of { board, goatsPlaced, goatsCaptured, currentTurn, description }
    let moveDescriptions = []; // display log
    let moveCount = 0;

    // Game mode
    let gameMode = 'human'; // 'human' or 'ai'
    let aiDifficulty = 'medium';
    let playerSide = 'goat';
    let aiThinking = false;

    // Canvas
    const canvas = document.getElementById('board-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('board-container');
    let boardPixelSize, padding, cellSize;

    // Animation state
    let animating = false;
    let animPiece = null; // { type, fromX, fromY, toX, toY, progress, captureKey }

    function initLayout() {
        boardPixelSize = container.offsetWidth;
        canvas.width = boardPixelSize;
        canvas.height = boardPixelSize;
        padding = 50;
        cellSize = (boardPixelSize - 2 * padding) / (BOARD_SIZE - 1);
    }

    function gridToPixel(r, c) {
        return { x: padding + c * cellSize, y: padding + r * cellSize };
    }

    // Detect touch device for larger hit targets
    const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
    const HIT_RADIUS_FACTOR = isTouchDevice ? 0.45 : 0.35;

    function pixelToGrid(px, py) {
        let closest = null, closestDist = Infinity;
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const { x, y } = gridToPixel(r, c);
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                if (dist < cellSize * HIT_RADIUS_FACTOR && dist < closestDist) {
                    closest = { r, c };
                    closestDist = dist;
                }
            }
        }
        return closest;
    }

    // ===== PARTICLE & EFFECTS SYSTEM =====
    let particles = [];
    let shakeAmount = 0;
    let confettiParticles = [];

    function spawnCaptureParticles(key) {
        const { r, c } = parseKey(key);
        const { x, y } = gridToPixel(r, c);
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i + Math.random() * 0.5;
            const speed = 2 + Math.random() * 3;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1,
                decay: 0.02 + Math.random() * 0.02,
                size: 3 + Math.random() * 4,
                color: `hsl(${10 + Math.random() * 30}, 90%, ${50 + Math.random() * 30}%)`
            });
        }
    }

    function spawnConfetti() {
        for (let i = 0; i < 80; i++) {
            confettiParticles.push({
                x: Math.random() * canvas.width,
                y: -10 - Math.random() * 40,
                vx: (Math.random() - 0.5) * 3,
                vy: 1.5 + Math.random() * 3,
                life: 1,
                decay: 0.005 + Math.random() * 0.005,
                size: 4 + Math.random() * 6,
                color: ['#e94560','#4CAF50','#ffd700','#58A6FF','#FF8F00','#fff'][Math.floor(Math.random() * 6)],
                rotation: Math.random() * Math.PI * 2,
                rotSpeed: (Math.random() - 0.5) * 0.2
            });
        }
    }

    function triggerShake() {
        shakeAmount = 8;
    }

    function updateParticles() {
        // Update capture particles
        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // gravity
            p.life -= p.decay;
            return p.life > 0;
        });

        // Update confetti
        confettiParticles = confettiParticles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vx *= 0.99;
            p.rotation += p.rotSpeed;
            p.life -= p.decay;
            return p.life > 0 && p.y < canvas.height + 20;
        });

        // Decay shake
        if (shakeAmount > 0) shakeAmount *= 0.85;
        if (shakeAmount < 0.5) shakeAmount = 0;
    }

    function drawParticles() {
        // Draw capture particles
        for (const p of particles) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw confetti
        for (const p of confettiParticles) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
            ctx.restore();
        }
        ctx.globalAlpha = 1;
    }

    let effectsRunning = false;
    function startEffectsLoop() {
        if (effectsRunning) return;
        effectsRunning = true;
        function effectFrame() {
            if (particles.length === 0 && confettiParticles.length === 0 && shakeAmount === 0) {
                effectsRunning = false;
                return;
            }
            updateParticles();
            drawBoard();
            requestAnimationFrame(effectFrame);
        }
        requestAnimationFrame(effectFrame);
    }

    // ===== DRAWING =====
    function drawBoard() {
        const w = canvas.width, h = canvas.height;
        ctx.clearRect(0, 0, w, h);

        // Apply shake offset
        if (shakeAmount > 0) {
            ctx.save();
            ctx.translate(
                (Math.random() - 0.5) * shakeAmount,
                (Math.random() - 0.5) * shakeAmount
            );
        }

        // Board background with skin
        const skin = SKIN_CONFIG[currentSkin] || SKIN_CONFIG.classic;
        if (skin.boardBg) {
            if (skin.boardBg2) {
                const bgGrad = ctx.createLinearGradient(0, 0, w, h);
                bgGrad.addColorStop(0, skin.boardBg);
                bgGrad.addColorStop(1, skin.boardBg2);
                ctx.fillStyle = bgGrad;
            } else {
                ctx.fillStyle = skin.boardBg;
            }
        } else {
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--board-bg') || 'rgba(30,30,50,0.8)';
        }
        ctx.beginPath();
        ctx.roundRect(0, 0, w, h, 16);
        ctx.fill();

        // Neon glow effect for neon skin
        if (currentSkin === 'neon') {
            ctx.shadowColor = 'rgba(0,255,200,0.3)';
            ctx.shadowBlur = 8;
        }

        const lineColor = skin.lineColor || getComputedStyle(document.body).getPropertyValue('--grid-line') || 'rgba(255,255,255,0.15)';
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = skin.lineWidth || 1.5;

        // Grid lines
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const from = gridToPixel(r, c);
                if (c + 1 < BOARD_SIZE) {
                    const to = gridToPixel(r, c + 1);
                    ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();
                }
                if (r + 1 < BOARD_SIZE) {
                    const to = gridToPixel(r + 1, c);
                    ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();
                }
                if ((r + c) % 2 === 0) {
                    for (const [dr, dc] of diagDirs) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                            const to = gridToPixel(nr, nc);
                            ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();
                        }
                    }
                }
            }
        }

        // Valid move indicators
        for (const move of validMoves) {
            const { r, c } = parseKey(move.to);
            const { x, y } = gridToPixel(r, c);
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 215, 0, 0.25)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        // Intersection dots for empty spots
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const key = posKey(r, c);
                if (!board[key]) {
                    const { x, y } = gridToPixel(r, c);
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = skin.dotColor || 'rgba(255,255,255,0.25)';
                    ctx.fill();
                }
            }
        }

        // Draw pieces (skip animating piece at its old position)
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const key = posKey(r, c);
                const piece = board[key];
                if (!piece) continue;
                if (animating && animPiece && animPiece.skipKey === key) continue;
                const { x, y } = gridToPixel(r, c);
                drawPiece(x, y, piece, selectedPiece === key);
            }
        }

        // Draw animating piece
        if (animating && animPiece) {
            const t = animPiece.progress;
            const cx = animPiece.fromX + (animPiece.toX - animPiece.fromX) * t;
            const cy = animPiece.fromY + (animPiece.toY - animPiece.fromY) * t;
            drawPiece(cx, cy, animPiece.type, false);
        }

        // Restore shake context
        if (shakeAmount > 0) ctx.restore();

        // Draw particles and confetti on top
        drawParticles();
    }

    function drawPiece(x, y, type, isSelected) {
        const radius = isSelected ? 22 : 19;
        const imgSize = radius * 2.2;

        // Shadow
        ctx.beginPath();
        ctx.arc(x + 2, y + 3, radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fill();

        // Base circle (subtle colored pedestal behind the image)
        const grad = ctx.createRadialGradient(x - 4, y - 4, 2, x, y, radius);
        if (type === 'tiger') {
            grad.addColorStop(0, currentSkin === 'neon' ? '#552200' : '#ff9a6c');
            grad.addColorStop(1, currentSkin === 'neon' ? '#331100' : '#a04020');
        } else {
            grad.addColorStop(0, currentSkin === 'neon' ? '#003322' : '#c8e6c9');
            grad.addColorStop(1, currentSkin === 'neon' ? '#001a11' : '#2e5d32');
        }
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Draw SVG image clipped to circle
        const img = getPieceImage(type);
        if (img && img.complete && img.naturalWidth > 0) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, radius - 1, 0, Math.PI * 2);
            ctx.clip();
            ctx.drawImage(img, x - imgSize / 2, y - imgSize / 2, imgSize, imgSize);
            ctx.restore();
        } else {
            // Fallback: emoji (for older browsers or if images fail)
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${radius}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(type === 'tiger' ? '\u{1F405}' : '\u{1F410}', x, y + 1);
        }

        // Border ring
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        if (currentSkin === 'neon') {
            ctx.shadowColor = type === 'tiger' ? '#ff0000' : '#00ff66';
            ctx.shadowBlur = isSelected ? 15 : 8;
        }
        ctx.strokeStyle = isSelected ? '#ffd700' : (type === 'tiger' ? '#e74c3c' : '#4CAF50');
        ctx.lineWidth = isSelected ? 3 : 2;
        ctx.stroke();
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        // Selection glow
        if (isSelected) {
            ctx.beginPath();
            ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }

    // ===== ANIMATION =====
    function animateMove(fromKey, toKey, pieceType, captureKey, callback) {
        const from = parseKey(fromKey);
        const to = parseKey(toKey);
        const fromPx = gridToPixel(from.r, from.c);
        const toPx = gridToPixel(to.r, to.c);

        animating = true;
        animPiece = {
            type: pieceType,
            fromX: fromPx.x, fromY: fromPx.y,
            toX: toPx.x, toY: toPx.y,
            progress: 0,
            skipKey: toKey // piece is already placed at toKey in board state, so skip drawing it statically
        };

        // Temporarily put piece back at from for drawing and remove from to
        board[fromKey] = pieceType;
        board[toKey] = null;
        if (captureKey) board[captureKey] = 'goat'; // temporarily restore captured goat

        animPiece.skipKey = fromKey;

        const duration = 200;
        const startTime = performance.now();

        function frame(now) {
            const elapsed = now - startTime;
            animPiece.progress = Math.min(elapsed / duration, 1);

            // Halfway through animation, remove captured piece
            if (captureKey && animPiece.progress > 0.5) {
                board[captureKey] = null;
            }

            drawBoard();

            if (animPiece.progress < 1) {
                requestAnimationFrame(frame);
            } else {
                // Finalize
                board[fromKey] = null;
                board[toKey] = pieceType;
                if (captureKey) board[captureKey] = null;
                animating = false;
                animPiece = null;
                drawBoard();
                callback();
            }
        }
        requestAnimationFrame(frame);
    }

    // ===== GAME LOGIC =====
    function initGame() {
        board = {};
        for (let r = 0; r < BOARD_SIZE; r++)
            for (let c = 0; c < BOARD_SIZE; c++)
                board[posKey(r, c)] = null;

        board[posKey(0, 0)] = 'tiger';
        board[posKey(0, 4)] = 'tiger';
        board[posKey(4, 0)] = 'tiger';
        board[posKey(4, 4)] = 'tiger';

        goatsPlaced = 0;
        goatsCaptured = 0;
        currentTurn = 'goat';
        selectedPiece = null;
        gameOver = false;
        validMoves = [];
        moveHistory = [];
        moveDescriptions = [];
        moveCount = 0;
        aiThinking = false;
        replaySnapshots = [];
        replayActive = false;
        if (replayInterval) { clearInterval(replayInterval); replayInterval = null; }
        document.getElementById('replay-bar').classList.remove('show');

        updateUI();
        drawBoard();
        recordSnapshot(); // record initial board state
        document.getElementById('message-overlay').classList.remove('show');
        document.getElementById('ai-thinking').classList.remove('show');
        updateUndoBtn();
        updateMoveList();

        // If AI goes first (player is tiger, AI is goat ‚Äî goat goes first)
        if (gameMode === 'ai' && playerSide !== currentTurn) {
            scheduleAIMove();
        }
    }

    function getPhase() { return goatsPlaced < TOTAL_GOATS ? 1 : 2; }

    function getAdjacentPositions(key) { return adjacency[key] || []; }

    function getJumpTarget(from, mid) {
        const f = parseKey(from), m = parseKey(mid);
        const dr = m.r - f.r, dc = m.c - f.c;
        const tr = m.r + dr, tc = m.c + dc;
        if (tr < 0 || tr >= BOARD_SIZE || tc < 0 || tc >= BOARD_SIZE) return null;
        const toKey = posKey(tr, tc);
        if (!getAdjacentPositions(from).includes(mid)) return null;
        if (!getAdjacentPositions(mid).includes(toKey)) return null;
        return toKey;
    }

    function getValidMovesForTiger(key, brd) {
        const b = brd || board;
        const moves = [];
        for (const adj of getAdjacentPositions(key)) {
            if (!b[adj]) moves.push({ to: adj, capture: null });
        }
        for (const adj of getAdjacentPositions(key)) {
            if (b[adj] === 'goat') {
                const jumpTo = getJumpTarget(key, adj);
                if (jumpTo && !b[jumpTo]) moves.push({ to: jumpTo, capture: adj });
            }
        }
        return moves;
    }

    function getValidMovesForGoat(key, brd) {
        const b = brd || board;
        const moves = [];
        for (const adj of getAdjacentPositions(key)) {
            if (!b[adj]) moves.push({ to: adj, capture: null });
        }
        return moves;
    }

    function countTrappedTigers(brd) {
        const b = brd || board;
        let trapped = 0;
        for (let r = 0; r < BOARD_SIZE; r++)
            for (let c = 0; c < BOARD_SIZE; c++) {
                const key = posKey(r, c);
                if (b[key] === 'tiger' && getValidMovesForTiger(key, b).length === 0) trapped++;
            }
        return trapped;
    }

    function checkWinCondition(brd, gc) {
        const gCap = gc !== undefined ? gc : goatsCaptured;
        if (gCap >= GOATS_TO_WIN) return 'tiger';
        if (countTrappedTigers(brd) === 4) return 'goat';
        return null;
    }

    // ===== MOVE HISTORY & UNDO =====
    function saveState(description) {
        moveHistory.push({
            board: { ...board },
            goatsPlaced,
            goatsCaptured,
            currentTurn,
            description
        });
        moveCount++;
        moveDescriptions.push({ num: moveCount, text: description, side: currentTurn === 'goat' ? 'tiger' : 'goat' });
        updateMoveList();
        updateUndoBtn();
    }

    function undoMove() {
        if (moveHistory.length === 0 || gameOver || aiThinking || animating) return;

        // In AI mode, undo two moves (AI + player)
        const undoCount = (gameMode === 'ai' && moveHistory.length >= 2) ? 2 : 1;

        for (let i = 0; i < undoCount && moveHistory.length > 0; i++) {
            const prev = moveHistory.pop();
            moveDescriptions.pop();
            moveCount--;
            board = { ...prev.board };
            goatsPlaced = prev.goatsPlaced;
            goatsCaptured = prev.goatsCaptured;
            currentTurn = prev.currentTurn;
        }

        selectedPiece = null;
        validMoves = [];
        soundUndo();
        updateUI();
        drawBoard();
        updateMoveList();
        updateUndoBtn();
    }

    function updateUndoBtn() {
        const btn = document.getElementById('undo-btn');
        btn.disabled = moveHistory.length === 0 || gameOver || aiThinking || gameMode === 'online';
    }

    function updateMoveList() {
        const el = document.getElementById('move-list');
        if (moveDescriptions.length === 0) {
            el.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.78rem;">No moves yet</span>';
            return;
        }
        el.innerHTML = moveDescriptions.map((m, i) =>
            `<div class="move-entry" style="background:${i % 2 === 0 ? 'rgba(255,255,255,0.03)' : 'transparent'}; padding:3px 6px; border-radius:4px;"><span class="move-num">${m.num}.</span> <span style="margin-right:3px;">${m.side === 'tiger' ? '\u{1F405}' : '\u{1F410}'}</span><span class="move-${m.side}">${m.text}</span></div>`
        ).join('');
        el.scrollTop = el.scrollHeight;
    }

    function posLabel(key) {
        const { r, c } = parseKey(key);
        return `${String.fromCharCode(65 + c)}${r + 1}`;
    }

    // ===== CLICK HANDLER =====
    function handleClick(px, py) {
        if (gameOver || aiThinking || animating || replayActive) return;
        if (gameMode === 'ai' && currentTurn !== playerSide) return;
        if (gameMode === 'online' && currentTurn !== playerSide) return;

        const gridPos = pixelToGrid(px, py);
        if (!gridPos) return;

        const key = posKey(gridPos.r, gridPos.c);
        const phase = getPhase();

        if (currentTurn === 'goat') {
            handleGoatClick(key, phase);
        } else {
            handleTigerClick(key);
        }
    }

    function handleGoatClick(key, phase) {
        if (phase === 1) {
            if (!board[key]) {
                saveState(`Goat placed at ${posLabel(key)}`);
                board[key] = 'goat';
                goatsPlaced++;
                selectedPiece = null;
                validMoves = [];
                soundPlace();
                if (gameMode === 'online') sendMoveToRemote({ placement: true, to: key, pieceType: 'goat' });
                switchTurn();
            }
        } else {
            if (selectedPiece) {
                const move = validMoves.find(m => m.to === key);
                if (move) {
                    const fromLabel = posLabel(selectedPiece);
                    const toLabel = posLabel(key);
                    saveState(`Goat ${fromLabel} ‚Üí ${toLabel}`);
                    const fromKey = selectedPiece;
                    selectedPiece = null;
                    validMoves = [];

                    board[key] = 'goat';
                    board[fromKey] = null;
                    if (gameMode === 'online') sendMoveToRemote({ from: fromKey, to: key, pieceType: 'goat', capture: null });
                    animateMove(fromKey, key, 'goat', null, () => {
                        soundMove();
                        switchTurn();
                    });
                    return;
                } else if (board[key] === 'goat') {
                    selectedPiece = key;
                    validMoves = getValidMovesForGoat(key);
                    soundSelect();
                    drawBoard();
                } else {
                    selectedPiece = null;
                    validMoves = [];
                    drawBoard();
                }
            } else if (board[key] === 'goat') {
                selectedPiece = key;
                validMoves = getValidMovesForGoat(key);
                soundSelect();
                drawBoard();
            }
        }
    }

    function handleTigerClick(key) {
        if (selectedPiece) {
            const move = validMoves.find(m => m.to === key);
            if (move) {
                const fromLabel = posLabel(selectedPiece);
                const toLabel = posLabel(key);
                const desc = move.capture
                    ? `Tiger ${fromLabel} ‚Üí ${toLabel} (captured goat at ${posLabel(move.capture)})`
                    : `Tiger ${fromLabel} ‚Üí ${toLabel}`;
                saveState(desc);
                const fromKey = selectedPiece;
                const captureKey = move.capture;
                selectedPiece = null;
                validMoves = [];

                board[key] = 'tiger';
                board[fromKey] = null;
                if (captureKey) { board[captureKey] = null; goatsCaptured++; }
                if (gameMode === 'online') sendMoveToRemote({ from: fromKey, to: key, pieceType: 'tiger', capture: captureKey });

                animateMove(fromKey, key, 'tiger', captureKey, () => {
                    if (captureKey) { soundCapture(); effectCapture(captureKey); } else soundMove();
                    switchTurn();
                });
                return;
            } else if (board[key] === 'tiger') {
                selectedPiece = key;
                validMoves = getValidMovesForTiger(key);
                soundSelect();
                drawBoard();
            } else {
                selectedPiece = null;
                validMoves = [];
                drawBoard();
            }
        } else if (board[key] === 'tiger') {
            selectedPiece = key;
            validMoves = getValidMovesForTiger(key);
            soundSelect();
            drawBoard();
        }
    }

    function switchTurn() {
        recordSnapshot(); // record state after move for replay
        const winner = checkWinCondition();
        if (winner) {
            gameOver = true;
            updateUI();
            drawBoard();
            recordWin(winner);
            soundWin();
            showWinMessage(winner);
            return;
        }
        currentTurn = currentTurn === 'goat' ? 'tiger' : 'goat';
        updateUI();
        drawBoard();

        // Notify player it's their turn (online & AI modes)
        if ((gameMode === 'online' || gameMode === 'ai') && currentTurn === playerSide) {
            notifyYourTurn();
        }

        if (gameMode === 'ai' && currentTurn !== playerSide && !gameOver) {
            scheduleAIMove();
        }
    }

    function showWinMessage(winner) {
        const overlay = document.getElementById('message-overlay');
        const title = document.getElementById('message-title');
        const text = document.getElementById('message-text');
        const pieceIcon = document.getElementById('win-piece-icon');
        const eloEl = document.getElementById('elo-change');
        const rematchBtn = document.getElementById('rematch-btn');

        if (winner === 'tiger') {
            title.textContent = 'Tigers Win!';
            text.textContent = 'The tigers captured 5 goats!';
        } else {
            title.textContent = 'Goats Win!';
            text.textContent = 'All tigers are trapped!';
        }

        // Show piece SVG icon in win overlay
        const img = getPieceImage(winner);
        if (img && img.complete) {
            pieceIcon.innerHTML = '';
            const clone = img.cloneNode();
            clone.style.width = '64px';
            clone.style.height = '64px';
            pieceIcon.appendChild(clone);
        } else {
            pieceIcon.textContent = winner === 'tiger' ? '\u{1F405}' : '\u{1F410}';
        }

        // Show ELO change in AI mode
        if (gameMode === 'ai') {
            const playerWon = (winner === playerSide);
            const aiElo = AI_ELO[aiDifficulty] || 1100;
            const change = calcEloChange(stats.elo, aiElo, playerWon);
            eloEl.style.display = 'block';
            eloEl.textContent = change >= 0 ? `+${change} ELO` : `${change} ELO`;
            eloEl.style.color = change >= 0 ? '#4CAF50' : '#e94560';
        } else {
            eloEl.style.display = 'none';
        }

        // Show rematch button in online mode
        rematchBtn.style.display = gameMode === 'online' ? 'inline-block' : 'none';

        overlay.classList.add('show');
        effectWin(); // confetti!
    }

    function updateUI() {
        const turnEl = document.getElementById('turn-indicator');
        const phaseEl = document.getElementById('phase-indicator');

        if (gameOver) {
            turnEl.textContent = 'Game Over';
            turnEl.className = 'turn-indicator turn-tiger';
        } else {
            turnEl.textContent = currentTurn === 'goat' ? "Goat's Turn" : "Tiger's Turn";
            const isYourTurn = (gameMode === 'human') || (currentTurn === playerSide);
            turnEl.className = `turn-indicator ${currentTurn === 'goat' ? 'turn-goat' : 'turn-tiger'}${isYourTurn ? ' your-turn' : ''}`;
        }

        const phase = getPhase();
        phaseEl.textContent = phase === 1
            ? `Phase 1: Place Goats (${TOTAL_GOATS - goatsPlaced} left)`
            : 'Phase 2: Move Pieces';

        document.getElementById('goats-placed').textContent = `${goatsPlaced} / ${TOTAL_GOATS}`;
        document.getElementById('goats-captured').textContent = goatsCaptured;
        document.getElementById('tigers-trapped').textContent = countTrappedTigers();
        updateUndoBtn();
    }

    // ===== AI ENGINE (Minimax + Alpha-Beta + Opening Book + Enhanced Eval) =====
    const DEPTH_MAP = { easy: 2, medium: 4, hard: 6 };

    function cloneBoard(b) { return { ...b }; }

    // Opening book: known strong early placements for goats (blocking tiger movement)
    const GOAT_OPENING_BOOK = [
        ['2,1','1,2','2,3','3,2','2,2'], // control center and cross
        ['2,0','0,2','2,4','4,2','2,2'], // control edges then center
        ['1,1','1,3','3,1','3,3','2,2'], // inner ring then center
    ];

    // Tiger opening: prioritize moving toward center early
    const TIGER_OPENING_PRIORITIES = ['2,2','2,1','1,2','2,3','3,2','1,1','1,3','3,1','3,3'];

    function getOpeningMove(isAITiger) {
        if (moveCount > 8) return null; // only use book for early game

        if (!isAITiger && goatsPlaced < 5) {
            // AI plays goat: use opening book
            const bookLine = GOAT_OPENING_BOOK[Math.floor(Math.random() * GOAT_OPENING_BOOK.length)];
            for (const pos of bookLine) {
                if (!board[pos]) {
                    return { from: null, to: pos, capture: null, placement: true };
                }
            }
        }

        if (isAITiger && moveCount < 6) {
            // AI plays tiger: move toward high-priority positions
            const tigers = [];
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++)
                    if (board[posKey(r, c)] === 'tiger') tigers.push(posKey(r, c));

            for (const target of TIGER_OPENING_PRIORITIES) {
                if (board[target]) continue;
                for (const tKey of tigers) {
                    const moves = getValidMovesForTiger(tKey);
                    const move = moves.find(m => m.to === target);
                    if (move) return { from: tKey, ...move };
                }
            }
        }
        return null;
    }

    function getAllTigerMoves(b) {
        const moves = [];
        for (let r = 0; r < BOARD_SIZE; r++)
            for (let c = 0; c < BOARD_SIZE; c++) {
                const key = posKey(r, c);
                if (b[key] === 'tiger') {
                    for (const m of getValidMovesForTiger(key, b))
                        moves.push({ from: key, ...m });
                }
            }
        return moves;
    }

    function getAllGoatMoves(b, gp) {
        const moves = [];
        if (gp < TOTAL_GOATS) {
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const key = posKey(r, c);
                    if (!b[key]) moves.push({ from: null, to: key, capture: null, placement: true });
                }
        } else {
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const key = posKey(r, c);
                    if (b[key] === 'goat') {
                        for (const m of getValidMovesForGoat(key, b))
                            moves.push({ from: key, ...m });
                    }
                }
        }
        return moves;
    }

    // Move ordering: evaluate captures first for better pruning
    function orderMoves(moves, isTiger) {
        return moves.sort((a, b) => {
            const aScore = a.capture ? 100 : 0;
            const bScore = b.capture ? 100 : 0;
            return bScore - aScore;
        });
    }

    function evaluateBoard(b, gc, gp) {
        let score = 0;

        // Captured goats (very high weight)
        score += gc * 60;

        // Trapped tigers (very high weight for goats)
        let trappedTigers = 0;
        let semiTrappedTigers = 0; // only 1 move available
        let tigerMobility = 0;
        let tigerCaptures = 0;
        let tigerPositionScore = 0;

        for (let r = 0; r < BOARD_SIZE; r++)
            for (let c = 0; c < BOARD_SIZE; c++) {
                const key = posKey(r, c);
                if (b[key] === 'tiger') {
                    const moves = getValidMovesForTiger(key, b);
                    const moveCount = moves.length;
                    const captureCount = moves.filter(m => m.capture).length;

                    if (moveCount === 0) trappedTigers++;
                    else if (moveCount === 1) semiTrappedTigers++;

                    tigerMobility += moveCount;
                    tigerCaptures += captureCount;

                    // Position: center is best, edges are worst
                    const distFromCenter = Math.abs(r - 2) + Math.abs(c - 2);
                    tigerPositionScore += (4 - distFromCenter) * 2;
                }
            }

        score -= trappedTigers * 80;
        score -= semiTrappedTigers * 20;
        score += tigerMobility * 4;
        score += tigerCaptures * 20;
        score += tigerPositionScore;

        // Goat evaluation
        let goatCount = 0;
        let goatConnections = 0;
        let edgeGoats = 0;
        let goatDefenseScore = 0;

        for (let r = 0; r < BOARD_SIZE; r++)
            for (let c = 0; c < BOARD_SIZE; c++) {
                const key = posKey(r, c);
                if (b[key] === 'goat') {
                    goatCount++;

                    // Goats on the edge are vulnerable to capture
                    if (r === 0 || r === 4 || c === 0 || c === 4) edgeGoats++;

                    // Connected goats form defensive walls
                    for (const adj of getAdjacentPositions(key)) {
                        if (b[adj] === 'goat') goatConnections++;
                    }

                    // Goats adjacent to tigers help block them
                    for (const adj of getAdjacentPositions(key)) {
                        if (b[adj] === 'tiger') goatDefenseScore += 3;
                    }
                }
            }

        // Goat clustering helps trapping (negative = good for goats)
        if (gp >= 8) {
            score -= goatConnections * 3;
            score -= goatDefenseScore;
        }
        score += edgeGoats * 2; // edge goats are slightly bad for goat player

        // Center control
        const center = posKey(2, 2);
        if (b[center] === 'tiger') score += 10;
        else if (b[center] === 'goat') score -= 8;

        // Cross points control (adjacent to center)
        const crossPoints = ['1,2','3,2','2,1','2,3'];
        for (const cp of crossPoints) {
            if (b[cp] === 'tiger') score += 3;
            else if (b[cp] === 'goat') score -= 2;
        }

        // Threat: if a tiger can capture on next move, it's dangerous
        if (tigerCaptures > 0) score += tigerCaptures * 8;

        return score;
    }

    // Transposition table for caching evaluated positions
    const transTable = new Map();
    const MAX_TRANS_SIZE = 50000;

    function boardHash(b, gp, gc, isTigerTurn) {
        let h = isTigerTurn ? 'T' : 'G';
        h += gp + ',' + gc + ':';
        for (let r = 0; r < BOARD_SIZE; r++)
            for (let c = 0; c < BOARD_SIZE; c++) {
                const v = b[posKey(r, c)];
                h += v ? (v === 'tiger' ? 't' : 'g') : '.';
            }
        return h;
    }

    function minimax(b, gp, gc, depth, alpha, beta, isTigerTurn) {
        if (gc >= GOATS_TO_WIN) return 10000 + depth;
        if (countTrappedTigers(b) === 4) return -10000 - depth;
        if (depth === 0) return evaluateBoard(b, gc, gp);

        // Check transposition table
        const hash = boardHash(b, gp, gc, isTigerTurn);
        const cached = transTable.get(hash);
        if (cached && cached.depth >= depth) return cached.score;

        let result;

        if (isTigerTurn) {
            let moves = getAllTigerMoves(b);
            if (moves.length === 0) return -10000 - depth;
            moves = orderMoves(moves, true);
            let maxEval = -Infinity;
            for (const move of moves) {
                const nb = cloneBoard(b);
                nb[move.from] = null;
                nb[move.to] = 'tiger';
                let newGc = gc;
                if (move.capture) { nb[move.capture] = null; newGc++; }
                const ev = minimax(nb, gp, newGc, depth - 1, alpha, beta, false);
                maxEval = Math.max(maxEval, ev);
                alpha = Math.max(alpha, ev);
                if (beta <= alpha) break;
            }
            result = maxEval;
        } else {
            let moves = getAllGoatMoves(b, gp);
            if (moves.length === 0) return evaluateBoard(b, gc, gp);
            let minEval = Infinity;
            for (const move of moves) {
                const nb = cloneBoard(b);
                let newGp = gp;
                if (move.placement) { nb[move.to] = 'goat'; newGp++; }
                else { nb[move.from] = null; nb[move.to] = 'goat'; }
                const ev = minimax(nb, newGp, gc, depth - 1, alpha, beta, true);
                minEval = Math.min(minEval, ev);
                beta = Math.min(beta, ev);
                if (beta <= alpha) break;
            }
            result = minEval;
        }

        // Store in transposition table
        if (transTable.size > MAX_TRANS_SIZE) transTable.clear();
        transTable.set(hash, { score: result, depth });

        return result;
    }

    function getBestAIMove() {
        const isAITiger = (playerSide === 'goat');

        // Try opening book first
        if (aiDifficulty !== 'easy') {
            const bookMove = getOpeningMove(isAITiger);
            if (bookMove) return bookMove;
        }

        const depth = DEPTH_MAP[aiDifficulty] || 4;
        let bestMove = null;
        let bestScore = isAITiger ? -Infinity : Infinity;

        const moves = isAITiger
            ? orderMoves(getAllTigerMoves(board), true)
            : getAllGoatMoves(board, goatsPlaced);

        // Easy: 30% random moves
        if (aiDifficulty === 'easy' && Math.random() < 0.3 && moves.length > 0) {
            return moves[Math.floor(Math.random() * moves.length)];
        }

        // Clear transposition table each turn for freshness
        transTable.clear();

        for (const move of moves) {
            const nb = cloneBoard(board);
            let newGp = goatsPlaced, newGc = goatsCaptured;

            if (isAITiger) {
                nb[move.from] = null;
                nb[move.to] = 'tiger';
                if (move.capture) { nb[move.capture] = null; newGc++; }
            } else {
                if (move.placement) { nb[move.to] = 'goat'; newGp++; }
                else { nb[move.from] = null; nb[move.to] = 'goat'; }
            }

            const score = minimax(nb, newGp, newGc, depth - 1, -Infinity, Infinity, !isAITiger);

            if (isAITiger) {
                if (score > bestScore || (score === bestScore && Math.random() < 0.3)) {
                    bestScore = score; bestMove = move;
                }
            } else {
                if (score < bestScore || (score === bestScore && Math.random() < 0.3)) {
                    bestScore = score; bestMove = move;
                }
            }
        }

        return bestMove;
    }

    function scheduleAIMove() {
        aiThinking = true;
        document.getElementById('ai-thinking').classList.add('show');
        updateUndoBtn();

        setTimeout(() => {
            const move = getBestAIMove();
            document.getElementById('ai-thinking').classList.remove('show');
            aiThinking = false;

            if (!move || gameOver) { updateUndoBtn(); return; }

            const isAITiger = (playerSide === 'goat');

            if (isAITiger) {
                const fromLabel = posLabel(move.from);
                const toLabel = posLabel(move.to);
                const desc = move.capture
                    ? `Tiger ${fromLabel} ‚Üí ${toLabel} (captured goat at ${posLabel(move.capture)})`
                    : `Tiger ${fromLabel} ‚Üí ${toLabel}`;
                saveState(desc);

                board[move.to] = 'tiger';
                board[move.from] = null;
                if (move.capture) { board[move.capture] = null; goatsCaptured++; }

                animateMove(move.from, move.to, 'tiger', move.capture, () => {
                    if (move.capture) { soundCapture(); effectCapture(move.capture); } else soundMove();
                    switchTurn();
                });
            } else {
                if (move.placement) {
                    saveState(`Goat placed at ${posLabel(move.to)}`);
                    board[move.to] = 'goat';
                    goatsPlaced++;
                    soundPlace();
                    switchTurn();
                } else {
                    const fromLabel = posLabel(move.from);
                    const toLabel = posLabel(move.to);
                    saveState(`Goat ${fromLabel} ‚Üí ${toLabel}`);

                    board[move.to] = 'goat';
                    board[move.from] = null;

                    animateMove(move.from, move.to, 'goat', null, () => {
                        soundMove();
                        switchTurn();
                    });
                }
            }
        }, 300 + Math.random() * 400); // slight delay to feel natural
    }

    // ===== ONLINE MULTIPLAYER (PeerJS WebRTC) =====
    let peer = null;
    let peerConn = null;
    let onlineRole = null; // 'goat' or 'tiger'
    let roomCode = '';

    function generateRoomCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
        return code;
    }

    function createOnlineGame() {
        roomCode = generateRoomCode();
        const peerId = 'baghchal-' + roomCode;

        document.getElementById('online-create-info').style.display = 'block';
        document.getElementById('online-join-info').style.display = 'none';
        document.getElementById('room-code').textContent = roomCode;
        document.getElementById('online-status').textContent = 'Connecting...';

        try {
            peer = new Peer(peerId);
        } catch (e) {
            document.getElementById('online-status').textContent = 'Failed to create peer. Try again.';
            return;
        }

        peer.on('open', () => {
            document.getElementById('online-status').textContent = 'Waiting for opponent to join...';
        });

        peer.on('connection', (conn) => {
            peerConn = conn;
            onlineRole = 'goat'; // creator plays goat (goes first)
            setupPeerConnection();
        });

        peer.on('error', (err) => {
            document.getElementById('online-status').textContent = 'Error: ' + err.type + '. Try creating a new game.';
        });
    }

    function showJoinInput() {
        document.getElementById('online-join-info').style.display = 'block';
        document.getElementById('online-create-info').style.display = 'none';
        document.getElementById('join-code-input').focus();
    }

    function joinOnlineGame() {
        const code = document.getElementById('join-code-input').value.trim().toUpperCase();
        if (code.length < 4) {
            document.getElementById('join-status').textContent = 'Enter a valid code';
            return;
        }

        const peerId = 'baghchal-' + code;
        document.getElementById('join-status').textContent = 'Connecting...';

        try {
            peer = new Peer();
        } catch (e) {
            document.getElementById('join-status').textContent = 'Failed to connect. Try again.';
            return;
        }

        peer.on('open', () => {
            peerConn = peer.connect(peerId);
            onlineRole = 'tiger'; // joiner plays tiger
            setupPeerConnection();
        });

        peer.on('error', (err) => {
            document.getElementById('join-status').textContent = 'Could not find game. Check the code.';
        });
    }

    function setupPeerConnection() {
        peerConn.on('open', () => {
            gameMode = 'online';
            playerSide = onlineRole;

            document.getElementById('start-menu').style.display = 'none';
            document.getElementById('game-container').classList.add('show');
            initLayout();
            initGame();

            // Send role confirmation
            peerConn.send({ type: 'start', role: onlineRole });

            // Request notification permission for turn alerts
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        });

        peerConn.on('data', (data) => {
            if (data.type === 'start') {
                // Game already started
            } else if (data.type === 'move') {
                applyRemoteMove(data.move);
            } else if (data.type === 'rematch-request') {
                // Opponent wants rematch ‚Äî auto-accept and swap sides
                acceptRematch();
            } else if (data.type === 'rematch-accept') {
                startRematchGame();
            }
        });

        peerConn.on('close', () => {
            if (!gameOver) {
                showWinMessage(playerSide); // opponent disconnected, you win
                gameOver = true;
            }
        });
    }

    function sendMoveToRemote(moveData) {
        if (peerConn && peerConn.open) {
            peerConn.send({ type: 'move', move: moveData });
        }
    }

    function applyRemoteMove(moveData) {
        if (gameOver) return;

        if (moveData.placement) {
            saveState(`Goat placed at ${posLabel(moveData.to)}`);
            board[moveData.to] = 'goat';
            goatsPlaced++;
            soundPlace();
            switchTurn();
        } else {
            const desc = moveData.capture
                ? `${moveData.pieceType === 'tiger' ? 'Tiger' : 'Goat'} ${posLabel(moveData.from)} ‚Üí ${posLabel(moveData.to)} (captured)`
                : `${moveData.pieceType === 'tiger' ? 'Tiger' : 'Goat'} ${posLabel(moveData.from)} ‚Üí ${posLabel(moveData.to)}`;
            saveState(desc);

            board[moveData.to] = moveData.pieceType;
            board[moveData.from] = null;
            if (moveData.capture) { board[moveData.capture] = null; goatsCaptured++; }

            animateMove(moveData.from, moveData.to, moveData.pieceType, moveData.capture, () => {
                if (moveData.capture) { soundCapture(); effectCapture(moveData.capture); } else soundMove();
                switchTurn();
            });
        }
    }

    function copyRoomCode() {
        navigator.clipboard.writeText(roomCode).catch(() => {});
        const el = document.getElementById('online-status');
        const prev = el.textContent;
        el.textContent = 'Code copied!';
        setTimeout(() => { el.textContent = prev; }, 1500);
    }

    function requestRematch() {
        if (peerConn && peerConn.open) {
            peerConn.send({ type: 'rematch-request' });
            const btn = document.getElementById('rematch-btn');
            btn.textContent = 'Waiting...';
            btn.disabled = true;
        }
    }

    function acceptRematch() {
        if (peerConn && peerConn.open) {
            peerConn.send({ type: 'rematch-accept' });
        }
        startRematchGame();
    }

    function startRematchGame() {
        // Swap sides
        onlineRole = onlineRole === 'goat' ? 'tiger' : 'goat';
        playerSide = onlineRole;
        document.getElementById('message-overlay').classList.remove('show');
        const btn = document.getElementById('rematch-btn');
        btn.textContent = 'Rematch';
        btn.disabled = false;
        initGame();
    }

    function cleanupPeer() {
        if (peerConn) { try { peerConn.close(); } catch (e) {} peerConn = null; }
        if (peer) { try { peer.destroy(); } catch (e) {} peer = null; }
        onlineRole = null;
    }

    // ===== MENU / MODE SELECTION =====
    function selectMode(mode) {
        if (mode === 'human') {
            gameMode = 'human';
            document.getElementById('start-menu').style.display = 'none';
            document.getElementById('game-container').classList.add('show');
            initLayout();
            initGame();
        } else if (mode === 'online') {
            document.getElementById('online-lobby').style.display = 'flex';
            document.getElementById('difficulty-select').classList.remove('show');
            document.getElementById('side-select').classList.remove('show');
        } else {
            gameMode = 'ai';
            document.getElementById('online-lobby').style.display = 'none';
            document.getElementById('difficulty-select').classList.add('show');
        }
    }

    function selectDifficulty(diff) {
        aiDifficulty = diff;
        document.getElementById('side-select').classList.add('show');
    }

    function startAIGame(side) {
        playerSide = side;
        document.getElementById('start-menu').style.display = 'none';
        document.getElementById('game-container').classList.add('show');
        initLayout();
        initGame();
    }

    function restartGame() {
        document.getElementById('message-overlay').classList.remove('show');
        initGame();
    }

    function backToMenu() {
        document.getElementById('message-overlay').classList.remove('show');
        document.getElementById('game-container').classList.remove('show');
        document.getElementById('start-menu').style.display = 'flex';
        document.getElementById('difficulty-select').classList.remove('show');
        document.getElementById('side-select').classList.remove('show');
        document.getElementById('online-lobby').style.display = 'none';
        document.getElementById('online-create-info').style.display = 'none';
        document.getElementById('online-join-info').style.display = 'none';
        cleanupPeer();
    }

    function toggleRules() {
        const content = document.getElementById('rules-content');
        const toggle = document.getElementById('rules-toggle');
        if (content.style.display === 'none') {
            content.style.display = '';
            toggle.innerHTML = '&#9660;';
        } else {
            content.style.display = 'none';
            toggle.innerHTML = '&#9654;';
        }
    }

    // ===== GAME REPLAY SYSTEM =====
    let replaySnapshots = [];   // array of board snapshots from game
    let replayIndex = 0;
    let replayActive = false;
    let replayInterval = null;

    // Called on each move to record snapshot
    function recordSnapshot() {
        replaySnapshots.push({
            board: { ...board },
            goatsPlaced,
            goatsCaptured,
            currentTurn
        });
    }

    function startReplay() {
        if (replaySnapshots.length === 0) return;
        document.getElementById('message-overlay').classList.remove('show');
        replayActive = true;
        replayIndex = 0;
        showReplayFrame();
        document.getElementById('replay-bar').classList.add('show');
        updateReplayUI();
    }

    function exitReplay() {
        replayActive = false;
        if (replayInterval) { clearInterval(replayInterval); replayInterval = null; }
        document.getElementById('replay-bar').classList.remove('show');
        // Restore final game state
        const last = replaySnapshots[replaySnapshots.length - 1];
        if (last) {
            board = { ...last.board };
            goatsPlaced = last.goatsPlaced;
            goatsCaptured = last.goatsCaptured;
            currentTurn = last.currentTurn;
        }
        drawBoard();
        updateUI();
        if (gameOver) {
            document.getElementById('message-overlay').classList.add('show');
        }
    }

    function showReplayFrame() {
        const snap = replaySnapshots[replayIndex];
        if (!snap) return;
        board = { ...snap.board };
        goatsPlaced = snap.goatsPlaced;
        goatsCaptured = snap.goatsCaptured;
        currentTurn = snap.currentTurn;
        selectedPiece = null;
        validMoves = [];
        drawBoard();
        updateUI();
        updateReplayUI();
    }

    function replayStep(dir) {
        const newIdx = replayIndex + dir;
        if (newIdx < 0 || newIdx >= replaySnapshots.length) return;
        replayIndex = newIdx;
        showReplayFrame();
    }

    function replayTogglePlay() {
        if (replayInterval) {
            clearInterval(replayInterval);
            replayInterval = null;
            document.getElementById('replay-play').innerHTML = '&#9654; Play';
        } else {
            document.getElementById('replay-play').innerHTML = '&#10074;&#10074; Pause';
            replayInterval = setInterval(() => {
                if (replayIndex >= replaySnapshots.length - 1) {
                    clearInterval(replayInterval);
                    replayInterval = null;
                    document.getElementById('replay-play').innerHTML = '&#9654; Play';
                    return;
                }
                replayIndex++;
                showReplayFrame();
            }, 800);
        }
    }

    function updateReplayUI() {
        document.getElementById('replay-info').textContent = `${replayIndex + 1} / ${replaySnapshots.length}`;
        document.getElementById('replay-prev').disabled = replayIndex <= 0;
        document.getElementById('replay-next').disabled = replayIndex >= replaySnapshots.length - 1;
    }

    // ===== EVENT LISTENERS =====

    // Unified pointer handling for mouse and touch
    function getCanvasCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    // Mouse click
    canvas.addEventListener('click', (e) => {
        const coords = getCanvasCoords(e);
        handleClick(coords.x, coords.y);
    });

    // Touch support with larger hit targets
    let touchHandled = false;
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); // prevent scroll while interacting with board
        touchHandled = false;
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (touchHandled) return;
        touchHandled = true;
        const coords = getCanvasCoords(e);
        handleClick(coords.x, coords.y);
    }, { passive: false });

    // Prevent scrolling when touching the board area
    container.addEventListener('touchmove', (e) => {
        e.preventDefault();
    }, { passive: false });

    window.addEventListener('resize', () => {
        if (document.getElementById('game-container').classList.contains('show')) {
            initLayout();
            drawBoard();
        }
    });

    // ===== INIT =====
    preloadPieceImages();
    loadStats();
    </script>
</body>
</html>
